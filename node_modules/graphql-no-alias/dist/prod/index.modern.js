import { GraphQLError } from 'graphql';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/** default allow count*/

const DEFAULT_ALLOW = 1;
/** default directive name*/

const DIRECTIVE_NAME = 'noAlias';
/**
 * Creates validation
 * @param config - {@link Config}
 * @returns validation function
 */

function createValidation(config) {
  const {
    directiveName,
    defaultAllow,
    errorFn,
    permissions
  } = _extends({}, {
    defaultAllow: DEFAULT_ALLOW,
    directiveName: DIRECTIVE_NAME,
    errorFn: createErrorMsg
  }, config || {});

  return {
    typeDefs: createTypeDefinition({
      directiveName,
      defaultAllow
    }),

    validation(context) {
      const ast = {
        Field: {
          leave: createFieldValidation(context, directiveName, defaultAllow, errorFn, permissions)
        }
      };
      return ast;
    }

  };
}
/**
 * Creates type definitions
 * @param opts - {@link CreateDefinitionOptions}
 * @returns type definition
 */

function createTypeDefinition(opts) {
  var _opts$directiveName, _opts$defaultAllow;

  return `directive @${(_opts$directiveName = opts == null ? void 0 : opts.directiveName) != null ? _opts$directiveName : DIRECTIVE_NAME}(allow: Int = ${(_opts$defaultAllow = opts == null ? void 0 : opts.defaultAllow) != null ? _opts$defaultAllow : DEFAULT_ALLOW}) on OBJECT | FIELD_DEFINITION`;
}

function configPermissionWalker(permissions, result, parentKey) {
  Object.entries(permissions).forEach(([key, value]) => {
    if (typeof value === 'object') {
      configPermissionWalker(value, result, `${parentKey ? parentKey : ''}${parentKey && key ? '.' : ''}${key ? key : ''}`);
    } else {
      if (key === '*') {
        result.set(parentKey, value);
      } else {
        result.set(`${parentKey ? parentKey : ''}.${key}`, value);
      }
    }
  });
}

function buildPermissionTableFromConfig(permissions) {
  const result = new Map();
  configPermissionWalker(permissions, result, undefined);
  return result;
}

function createFieldValidation(context, directiveName, defaultAllow, errorFn, permissions) {
  const schema = context.getSchema();
  let allowedCount;

  if (permissions) {
    allowedCount = buildPermissionTableFromConfig(permissions);
  } else {
    allowedCount = buildPermissionTableFromSchema(defaultAllow, directiveName, [schema.getQueryType(), schema.getMutationType()]);
  }

  const currentCount = new Map(); //track if the error have already been reported for particular field

  const errorMap = new Map();
  return node => {
    var _context$getParentTyp;

    const parentTypeName = (_context$getParentTyp = context.getParentType()) == null ? void 0 : _context$getParentTyp.name;

    if (parentTypeName === 'Query' || parentTypeName === 'Mutation') {
      checkCount(context, node, allowedCount, currentCount, errorFn, errorMap);
    }
  };
}
/**
 * Checks if allowed alias count has been exceeded
 */


function checkCount(ctx, node, maxAllowedData, currentCountData, errorFn, errorMap) {
  const nodeName = node.name.value;
  const typeName = ctx.getParentType().name;
  const typeKey = `${typeName}`;
  const fieldKey = `${typeKey}.${nodeName}`;
  const maxAllowed = maxAllowedData.get(fieldKey) || maxAllowedData.get(typeKey);

  if (maxAllowed) {
    var _currentCountData$get;

    let currentCount = (_currentCountData$get = currentCountData.get(fieldKey)) != null ? _currentCountData$get : 0;
    currentCount++;

    if (currentCount > maxAllowed) {
      // check if already reported for the current field
      if (!errorMap.get(fieldKey)) {
        const errorResult = errorFn(typeName, nodeName, maxAllowed, node, ctx);
        ctx.reportError(typeof errorResult === 'string' ? new GraphQLError(errorResult) : errorResult);
        errorMap.set(fieldKey, true);
      }

      return;
    }

    currentCountData.set(fieldKey, currentCount);
  }
}
/**
 * Process appropriate schema types (Query, Mutation) and resolve all directive values by
 * building a mapping between type fields and allowed values
 */


function buildPermissionTableFromSchema(defaultAllow, directiveName, types) {
  const maxAllowed = new Map();

  for (const graphType of types) {
    var _graphType$astNode, _graphType$astNode2;

    const value = graphType ? processDirective(directiveName, defaultAllow, // @ts-expect-error - directives array is typed as readonly
    graphType == null ? void 0 : (_graphType$astNode = graphType.astNode) == null ? void 0 : _graphType$astNode.directives) : undefined;

    if (value) {
      maxAllowed.set(`${graphType.name}`, value);
    }

    if (graphType != null && (_graphType$astNode2 = graphType.astNode) != null && _graphType$astNode2.fields) {
      for (const field of Object.values(graphType.astNode.fields)) {
        const _value = processDirective(directiveName, defaultAllow, // @ts-expect-error - directives array is typed as readonly
        field.directives);

        if (_value) {
          maxAllowed.set(`${graphType}.${field.name.value}`, _value);
        }
      }
    }
  }

  return maxAllowed;
}

function processDirective(directiveName, defaultValue, directives) {
  return directives == null ? void 0 : directives.filter(directive => directive.name.value === directiveName).map(dir => {
    if (dir.arguments && dir.arguments[0]) {
      // @ts-expect-error - wrong types
      return parseInt(dir.arguments[0].value.value, 10);
    }

    return defaultValue;
  })[0];
}
/**
 * Creates custom GraphQLError instance
 * @param typeName - Object type name
 * @param fieldName - Object field name
 * @param maxAllowed - max allowed count that has been reached
 */


function createErrorMsg(typeName, fieldName, maxAllowed, node, _ctx) {
  return new GraphQLError(`Allowed number of calls for ${typeName}->${fieldName} has been exceeded (max: ${maxAllowed})`, node);
}

export { createTypeDefinition, createValidation };
//# sourceMappingURL=index.modern.js.map
