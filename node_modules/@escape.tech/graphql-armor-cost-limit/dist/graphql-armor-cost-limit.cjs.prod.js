'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var graphql = require('graphql');

function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null) return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== undefined) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object") return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}

function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

const costLimitDefaultOptions = {
  maxCost: 5000,
  objectCost: 2,
  scalarCost: 1,
  depthCostFactor: 1.5,
  flattenFragments: false,
  fragmentRecursionCost: 1000,
  ignoreIntrospection: true,
  exposeLimits: true,
  errorMessage: 'Query validation error.',
  onAccept: [],
  onReject: [],
  propagateOnRejection: true
};
class CostLimitVisitor {
  constructor(context, options) {
    _defineProperty(this, "OperationDefinition", void 0);
    _defineProperty(this, "context", void 0);
    _defineProperty(this, "config", void 0);
    _defineProperty(this, "visitedFragments", void 0);
    this.context = context;
    this.config = Object.assign({}, costLimitDefaultOptions, ...Object.entries(options !== null && options !== void 0 ? options : {}).map(([k, v]) => v === undefined ? {} : {
      [k]: v
    }));
    this.visitedFragments = new Map();
    this.OperationDefinition = {
      enter: this.onOperationDefinitionEnter.bind(this)
    };
  }
  onOperationDefinitionEnter(operation) {
    const complexity = this.computeComplexity(operation);
    if (complexity > this.config.maxCost) {
      const message = this.config.exposeLimits ? `Query Cost limit of ${this.config.maxCost} exceeded, found ${complexity}.` : this.config.errorMessage;
      const err = new graphql.GraphQLError(`Syntax Error: ${message}`);
      for (const handler of this.config.onReject) {
        handler(this.context, err);
      }
      if (this.config.propagateOnRejection) {
        throw err;
      }
    } else {
      for (const handler of this.config.onAccept) {
        handler(this.context, {
          n: complexity
        });
      }
    }
  }
  computeComplexity(node, depth = 0) {
    if (this.config.ignoreIntrospection && 'name' in node && node.name?.value === '__schema') {
      return 0;
    }
    if (node.kind === graphql.Kind.OPERATION_DEFINITION) {
      return node.selectionSet.selections.reduce((v, child) => v + this.computeComplexity(child, depth + 1), 0);
    }
    let cost = this.config.scalarCost;
    if ('selectionSet' in node && node.selectionSet) {
      cost = this.config.objectCost;
      for (const child of node.selectionSet.selections) {
        if (this.config.flattenFragments && (child.kind === graphql.Kind.INLINE_FRAGMENT || child.kind === graphql.Kind.FRAGMENT_SPREAD)) {
          cost += this.computeComplexity(child, depth);
        } else {
          cost += this.config.depthCostFactor * this.computeComplexity(child, depth + 1);
        }
      }
    } else if (node.kind === graphql.Kind.FRAGMENT_SPREAD) {
      if (this.visitedFragments.has(node.name.value)) {
        var _this$visitedFragment;
        const visitCost = (_this$visitedFragment = this.visitedFragments.get(node.name.value)) !== null && _this$visitedFragment !== void 0 ? _this$visitedFragment : 0;
        return cost + this.config.depthCostFactor * visitCost;
      } else {
        this.visitedFragments.set(node.name.value, -1);
      }
      const fragment = this.context.getFragment(node.name.value);
      if (fragment) {
        let fragmentCost;
        if (this.config.flattenFragments) {
          fragmentCost = this.computeComplexity(fragment, depth);
          cost += fragmentCost;
        } else {
          fragmentCost = this.computeComplexity(fragment, depth + 1);
          cost += this.config.depthCostFactor * fragmentCost;
        }
        if (this.visitedFragments.get(node.name.value) === -1) {
          this.visitedFragments.set(node.name.value, fragmentCost);
        }
      }
    }
    return cost;
  }
}
const costLimitRule = options => context => new CostLimitVisitor(context, options);
const costLimitPlugin = options => {
  return {
    onValidate({
      addValidationRule
    }) {
      addValidationRule(costLimitRule(options));
    }
  };
};

exports.costLimitPlugin = costLimitPlugin;
exports.costLimitRule = costLimitRule;
